:numbered:
=== Selecting A Window Size for Surface Fitting

These instructions will take you through the steps needed to identify the correct
window radius to use in the surface fitting routines, following
the techniques published in http://www.sciencedirect.com/science/article/pii/S0012821X10004784[Roering et al. (2010)]
and http://onlinelibrary.wiley.com/doi/10.1029/2011JF002057/full[Hurst et al. (2012)]. It
is assumed that you are already comfortable with using LSDTopoTools, and have worked
though the tutorial: <<First Analysis>>. This analysis is often a precursor to other
more complex processes, and will ensure that fitted surfaces capture topographic
variations at a meaningful geomorphic scale.

=== Quick guide

Here is a quick overview of how to set up and run the code, if you have done it before:

. Compile the code with: `make -f PolyFitWindowSize.make`
. Run the program `PolyFitWindowSize.out` using the path (with trailing slash), the
filename prefix and the minimum patch area in pixels as arguments.
. Analyse the resulting data files using the provided python script, `Window_Size.py`.

=== Overview

This driver file will run the surface fitting routines at a range of window sizes up to 100 meters, to
produce a series of curvature rasters for the supplied landscape. The mean, interquartile range,
and standard deviation of each curvature raster is calculated and these values are
written to a text file.

The resulting text file can then be loaded by the provided python script, `Window_Size.py`,
which will produce plots of how the mean, interquartile range, and standard deviation
of curvature varies with the surface fitting window size.

This code will produce:: A `*.csv` file containing the surface statistics for each window size.

=== Input Data

This driver only requires an input DEM, this file can be at any resolution and must be
in `*.bil`, `flt` or `asc`. format. Guidance on converting data into these formats
can be found in the chapter covering basic <<GDAL>> operations. Note that as data
resolution decreases (i.e. pixel size increases) the ability to resolve individual
hillslopes reduces, and so this technique becomes less important.

The raw DEM to be analysed should be named `<prefix>_DEM.flt`.

=== Compile The Driver

The code is compiled using the provided makefile, `PolyFitWindowSize.make` and the command:

[source,console]
----
$ make -f PolyFitWindowSize.make
----

Which will create the binary file, `PolyFitWindowSize.out` to be executed.

=== Run The Code

The driver is run with three arguments:

Path:: The path pointing to where the input raster file is stored. This is also
where the output data will be written.
Prefix:: The filename prefix, without an underscore. If the DEM is called `Oregon_DEM.flt`
the prefix would be `Oregon`. This will be used to give the output files a distinct identifier.
Format:: The input file format. Must be either `bil`, `flt` or `asc`.

The syntax on a unix machine is as follows:

[source,console]
----
$ ./PolyFitWindowSize.out <path to data files> <Prefix> <file format>
----

And a complete example (your path and filenames may vary):

[source,console]
----
$ ./PolyFitWindowSize.out /home/s0675405/DataStore/Final_Paper_Data/NC/ NC_DEM flt
----

=== The Output Data

The final outputs are stored in a plain text file, `<prefix>_Window_Size_Data.txt`,
which is written to the data folder supplied as an argument.

This file contains the data needed to select the correct window size. The file has the the
following columns, from left to right:

Length_scale:: The window size used in the surface fitting routines to generate
this row of data.
Curv_mean:: Mean curvature for the landscape.
Curv_stddev:: Standard deviation of curvature for the landscape.
Curv_iqr:: Interquartile range of curvature for the landscape.

=== Using Python To Select A Window Size

The latest version of the python scripts which accompany this analysis driver can be found
https://github.com/sgrieve/GeneralAnalysis[here] and provide a complete framework to select
a window size for surface fitting.

Once the driver has been run, and the data file, `<prefix>_Window_Size_Data.txt`,
has been generated, the python script can be executed using:

[source,console]
----
$ python Window_Size.py <Path> <Data Filename>
----

The two input arguments are similar to the driver file's inputs:

Path:: The full path to where the data file is stored, with a trailing slash. E.g.
`/home/data/`. This is also where the output plot will be written.
Data Filename:: The filename of the data file generated by the driver.
E.g. `Orgeon_Window_Size_Data.txt`.

A complete example (your path and filenames will be different):

[source,console]
----
$ python Window_Size.py /home/data/ Oregon_Window_Size_Data.txt
----


The plot generated by the python script can be interpreted to select a valid window
size for the surface fitting routine. For discussions about this technique refer to
http://www.sciencedirect.com/science/article/pii/S0012821X10004784[Roering et al. (2010)]
and http://onlinelibrary.wiley.com/doi/10.1029/2011JF002057/full[Hurst et al. (2012)].
The plot generated should look similar to this example taken from the Oregon Coast Range:

image::images/window-size.jpg[Example window size plot]

The plot is divided into three sections. The top plot is the change in the interquartile
range of curvature with window size, the middle plot is the change in mean curvature
with window size and the bottom plot is the change in the standard deviation of
curvature with window size.

http://www.sciencedirect.com/science/article/pii/S0012821X10004784[Roering et al. (2010)]
and http://onlinelibrary.wiley.com/doi/10.1029/2011JF002057/full[Hurst et al. (2012)]
suggest that a clear scaling break can be observed in some or all of these three plots,
which characterizes the transition from a length scale which captures meter-scale features
such as tree throw mounds to a length scale which

Care must be taken when using this technique as it is challenging to differentiate between measurement noise
and topographic roughness (e.g. tree throw mounds) in data if the shot density of the point cloud
from which the DEM is generated it too low or it has been poorly gridded. Pay close attention
to the metadata provided with your topographic data. If none is provided this is probably a bad sign!

In our example, a length scale of between X and Y meters would be appropriate, supported by
the scaling breaks identified in the plots with the black arrows:

image::images/window-size-annotated.jpg[Example window size plot]



.
